#!/usr/bin/python
# Partially mirror 'cygwin' distribution
# (C)Copyright 2009, RW Penney

# This file is (C)Copyright 2009, RW Penney
# and is released under the Python-2.4.2 license
# (see http://www.python.org/psf/license),
# it therefore comes with NO WARRANTY, and NO CLAIMS OF FITNESS FOR ANY PURPOSE.

import bz2, md5, optparse, os, os.path, re, time, urllib, urlparse
try: set
except NameError: from sets import Set as set, ImmutableSet as frozenset


# Directory into which to assemble local mirror:
TGT_DIR = '.'
# URL of Cygwin package database file:
INIURL = 'ftp://cygwin.com/pub/cygwin/setup.ini'
# URL of source of Cygwin installation program 'setup.exe':
EXESRC = 'http://sourceware.redhat.com/cygwin/setup.exe'
# URL of Cygwin mirror site, hosting available packages:
MIRROR = 'ftp://cygwin.com/pub/cygwin/'
# Set of package age descriptors:
EPOCHS = ['curr']


def mergelines(pkgtxt):
    """Combine list of lines describing single package"""

    if not pkgtxt:
        return ""

    while pkgtxt and pkgtxt[-1].isspace():
        pkgtxt.pop()

    return "".join(pkgtxt)


def ParseIniFile(iniurl):
    """Ingest original 'setup.ini' file defining available cygwin packages"""

    re_setup = re.compile(r'^(setup-\S+):\s+(\S+)$')
    re_comment = re.compile(r'#(.*)$')
    re_blank = re.compile(r'^$')
    re_package = re.compile(r'^@\s+(\S+)$')
    re_epoch = re.compile(r'^\[([a-z]+)\]$')
    re_field = re.compile(r'^([a-z]+):\s+(.*)$')
    re_other = re.compile(r'^(.+)$')
    all_regexps = [ re_setup, re_comment, re_blank,
                    re_package, re_epoch, re_field, re_other ]

    header = {}
    packages = {}

    fp = urllib.urlopen(iniurl)
    lineno = 0
    (pkgname, pkgtxt, pkgdict, epoch) = (None, [], {}, None)
    for line in fp:
        lineno += 1

        # Classify current line as package definition/field etc:
        matches = None
        for regexp in all_regexps:
            matches = regexp.match(line)
            if matches: break
        if not matches:
            raise SyntaxError, "unrecognized content on line %d" % ( lineno )

        if regexp == re_setup:
            header[matches.group(1)] = matches.group(2)
        elif regexp == re_comment:
            pass
        elif regexp == re_blank:
            pass
        elif regexp == re_package:
            if pkgname:
                pkgdict['TEXT'] = mergelines(pkgtxt)
                packages[pkgname] = pkgdict
                pkgname = None
            pkgname = matches.group(1)
            pkgtxt = []
            pkgdict = {}
            epoch = 'curr'
        elif regexp == re_epoch:
            epoch = matches.group(1)
        elif regexp == re_field:
            pkgdict[matches.group(1) + '_' + epoch] = matches.group(2)
        elif regexp == re_other:
            # This doesn't handle multi-line fields fully yet...
            pass

        if pkgname:
            pkgtxt.append(line)
    fp.close()

    if pkgname:
        pkgdict['TEXT'] = mergelines(pkgtxt)
        packages[pkgname] = pkgdict

    return (header, packages)


def ResolveDependencies(pkgdict, usrpkgs=None, include_all=False):
    """Constuct list of packages, including all their dependencies"""

    if usrpkgs == None:
        # Setup minimalistic set of packages
        usrpkgs = ['bash', 'bzip2', 'coreutils', 'gzip', 'tar', 'unzip', 'zip' ]

    if include_all:
        usrpkgs = [ pkg for pkg in pkgdict.iterkeys()
                            if not pkg.startswith('_') ]

    additions = set(usrpkgs)
    packages = set()

    while additions:
        pkg = additions.pop()
        packages.add(pkg)

        try:
            pkginfo = pkgdict[pkg]
        except:
            print 'Bad package %s' % pkg
            break

        # Find dependencies of current package & add to stack:
        for epoch in EPOCHS:
            try:
                reqlist = pkginfo['requires' + '_' + epoch].split()
                for r in reqlist:
                    if not r in packages:
                        additions.add(r)
            except:
                print 'cannot find epoch %s for %s' % (epoch, pkg)
                pass

    return list(packages)


def BuildDownload(pkgdict, packages):
    """Convert list of packages into set of files to fetch from Cygwin server"""

    downloads = []
    totsize = 0

    for pkg in packages:
        pkginfo = pkgdict[pkg]

        for epoch in EPOCHS:
            try:
                flds = pkginfo['install' + '_' + epoch].split()
                pkgref = flds[0]
                pkgsize = int(flds[1])
                pkghash = flds[2]
                downloads.append((pkgref, pkgsize, pkghash))
                totsize += pkgsize
            except KeyError:
                pass

    return downloads, totsize


def BuildSetupFiles(header, pkgdict, packages):
    """Create top-level configuration files in local mirror"""

    # Split package list into normal + specials:
    spkgs = [pkg for pkg in packages if pkg.startswith('_')]
    packages = [pkg for pkg in packages if not pkg.startswith('_')]
    packages.sort()
    spkgs.sort()
    packages.extend(spkgs)

    # Reconstruct setup.ini file:
    spath = os.path.join(TGT_DIR, 'setup.ini')
    fp = open(spath, 'w+t')
    fp.write('# This file is automatically generated by "pmcyg"\n'
            '# Manual edits will be overwritten\n')
    fp.write('setup-timestamp: %d\n' % (int(time.time())))
    fp.write('setup-version: %s\n' % (header['setup-version']))
    for pkg in packages:
        fp.write('\n')
        fp.write(pkgdict[pkg]['TEXT'])
    fp.seek(0)
    cpsr = bz2.BZ2File(os.path.join(TGT_DIR, 'setup.bz2'), mode='w')
    cpsr.write(fp.read())
    cpsr.close()
    fp.close()

    # Create other top-level artefacts:
    urllib.urlretrieve(EXESRC, os.path.join(TGT_DIR, 'setup.exe'))
    hp = open(os.path.join(TGT_DIR, 'md5.sum'), 'wt')
    for fl in ['setup.ini', 'setup.bz2', 'setup.exe']:
        hshr = md5.new()
        fp = open(os.path.join(TGT_DIR, fl), 'rb')
        hshr.update(fp.read())
        fp.close()
        hp.write('%s  %s\n' % ( hshr.hexdigest(), fl ))
    hp.close()



def BuildMirror(header, pkgdict, packages):
    """Download files from Cygwin mirror to create local partial copy"""

    if not os.path.isdir(TGT_DIR):
        os.makedirs(TGT_DIR)

    BuildSetupFiles(header, pkgdict, packages)

    (downloads, totsize) = BuildDownload(pkgdict, packages)
    print 'Download size: %.1fMB from %s' \
            % ( totsize / (1024.0 * 1024.0), MIRROR)

    for (pkgfile, pkgsize, pkghash) in downloads:
        if os.path.isabs(pkgfile):
            raise SyntaxError, '%s is an absolute path' % ( pkgfile )
        tgtpath = os.path.join(TGT_DIR, pkgfile)
        tgtdir = os.path.dirname(tgtpath)
        if not os.path.isdir(tgtdir):
            os.makedirs(tgtdir)
        mirpath = urlparse.urljoin(MIRROR, pkgfile)
        if not os.path.isfile(tgtpath) or os.path.getsize(tgtpath) != pkgsize:
            print '  %s ...' % ( os.path.basename(pkgfile) ),
            urllib.urlretrieve(mirpath, tgtpath)
            print ' done'



def ReadPackageLists(filenames):
    """Read a set of user-supplied package names for local mirroring"""

    usrpkgs = []

    for fn in filenames:
        fp = open(fn, 'rt')

        for line in fp:
            idx = line.find('#')
            if idx >= 0:
                line = line[0:idx]
            line = line.strip()

            if line:
                usrpkgs.append(line)

        fp.close()

    return usrpkgs


def main():
    global INIURL, EPOCHS, EXESRC, MIRROR, TGT_DIR

    # Process command-line options:
    parser = optparse.OptionParser()
    parser.add_option('--directory', '-d', type='string', default='.',
            help='where to build local mirror')
    parser.add_option('--exeurl', '-x', type='string',
            default='http://sourceware.redhat.com/cygwin/setup.exe',
            help='URL of "setup.exe" Cygwin installer')
    parser.add_option('--iniurl', '-i', type='string', default=None,
            help='URL of "setup.ini" Cygwin database')
    parser.add_option('--mirror', '-m', type='string',
            default='ftp://cygwin.com/pub/cygwin/',
            help='URL of Cygwin archive or mirror site')
    parser.add_option('--epochs', '-e', type='string', default='curr',
            help='comma-separated list of epochs, e.g. "curr,prev"')
    parser.add_option('--all', '-a', action='store_true',
            help='include all available Cygwin packages')
    opts, remargs = parser.parse_args()

    TGT_DIR = opts.directory
    MIRROR = opts.mirror
    if not MIRROR.endswith('/'): MIRROR += '/'
    if opts.iniurl: INIURL = opts.iniurl
    else: INIURL = urlparse.urljoin(MIRROR, 'setup.ini')
    EPOCHS = opts.epochs.split(',')

    usrpkgs = None
    if remargs:
        usrpkgs = ReadPackageLists(remargs)

    (header, pkgdict) = ParseIniFile(INIURL)
    packages = ResolveDependencies(pkgdict, usrpkgs, include_all=opts.all)

    BuildMirror(header, pkgdict, packages)



if __name__ == "__main__":
    main()

# vim: set ts=4 sw=4 et:
